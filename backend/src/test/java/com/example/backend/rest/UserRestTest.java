package com.example.backend.rest;
// Generated by CodiumAI

import com.example.backend.Repository.Role;
import com.example.backend.Repository.RoleRepository;
import com.example.backend.Repository.UserInfoEntity;
import com.example.backend.ResponseDtos.ApiKeyDto;
import com.example.backend.ResponseDtos.ErrorDto;
import com.example.backend.ResponseDtos.UserDto;
import com.example.backend.system_management.PropertyService;
import com.example.backend.system_management.SystemService;
import com.example.backend.user_management.UserService;
import com.example.backend.util.TokenUtils;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.crypto.password.PasswordEncoder;

import javax.mail.MessagingException;
import java.io.IOException;
import java.util.*;

import static org.junit.jupiter.api.Assertions.*;

public class UserRestTest {

    public SystemService systemService = Mockito.mock(SystemService.class);
    public UserService userService = Mockito.mock(UserService.class);
    public PasswordEncoder passwordEncoder = Mockito.mock(PasswordEncoder.class);
    public TokenUtils tokenUtils = Mockito.mock(TokenUtils.class);
    public PropertyService propertyService = Mockito.mock(PropertyService.class);
    public RoleRepository roleRepository = Mockito.mock(RoleRepository.class);

    public UserRest userRest = new UserRest(systemService, userService, passwordEncoder, tokenUtils, propertyService, roleRepository);

    // User can login with correct credentials
    @Test
    public void test_login_with_correct_credentials() {
        // Set up test data
        String username = "testUser";
        String password = "testPassword";
        String token = "testToken";

        Map<String, String> requestBody = new HashMap<>();
        requestBody.put("username", username);
        requestBody.put("password", password);

        UserInfoEntity userInfoEntity = new UserInfoEntity();
        userInfoEntity.setId(1L);
        userInfoEntity.setUsername(username);
        userInfoEntity.setPassword(password);
        userInfoEntity.setVerified(true);

        // Set up mock behavior
        Mockito.when(userService.getUserByUsername(username)).thenReturn(userInfoEntity);
        Mockito.when(passwordEncoder.matches(password, userInfoEntity.getPassword())).thenReturn(true);
        Mockito.when(tokenUtils.generateToken()).thenReturn(token);

        // Perform the test
        ResponseEntity<Object> response = userRest.loginPublicAuth(requestBody);

        // Verify the result
        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertEquals(token, ((ApiKeyDto) response.getBody()).getApiKey());
    }

    // User can register with unique username
    @Test
    public void test_register_with_unique_username() {
        // Set up test data
        String username = "testUser";
        String token = "testToken";

        Map<String, String> requestBody = new HashMap<>();
        requestBody.put("username", username);

        UserInfoEntity userInfoEntity = new UserInfoEntity();
        userInfoEntity.setId(1L);
        userInfoEntity.setUsername(username);

        // Set up mock behavior
        Mockito.when(userService.getUserByUsername(username)).thenReturn(null);
        Mockito.when(userService.registerNewUser(Mockito.any(UserInfoEntity.class))).thenReturn(userInfoEntity);
        Mockito.when(tokenUtils.generateToken()).thenReturn(token);

        // Perform the test
        ResponseEntity<Object> response = userRest.loginPublic(requestBody);

        // Verify the result
        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertEquals(token, ((ApiKeyDto) response.getBody()).getApiKey());
    }

    // User can verify email address
    @Test
    public void test_verify_email_address() {
        // Set up test data
        String code = "testCode";
        String email = "test@example.com";
        String token = "testToken";

        Map<String, String> input = new HashMap<>();
        input.put("code", code);
        input.put("email", email);

        UserInfoEntity userInfoEntity = new UserInfoEntity();
        userInfoEntity.setId(1L);
        userInfoEntity.setEmail(email);

        // Set up mock behavior
        Mockito.when(userService.verifyEmail(email, code)).thenReturn(true);
        Mockito.when(userService.getUserByEmail(email)).thenReturn(userInfoEntity);
        Mockito.when(tokenUtils.generateToken()).thenReturn(token);

        // Perform the test
        ResponseEntity<Object> response = userRest.verifyAccount(input);

        // Verify the result
        assertEquals(HttpStatus.CREATED, response.getStatusCode());
        assertEquals(token, ((ApiKeyDto) response.getBody()).getApiKey());
    }

    // User can login with verified email address
    @Test
    public void test_login_with_verified_email() {
        // Create test data
        String username = "testUser";
        String password = "testPassword";
        String token = "testToken";
        UserInfoEntity userInfoEntity = new UserInfoEntity(username);
        userInfoEntity.setVerified(true);

        // Set up mock behavior
        Mockito.when(userService.getUserByUsername(username)).thenReturn(userInfoEntity);
        Mockito.when(passwordEncoder.matches(password, userInfoEntity.getPassword())).thenReturn(true);
        Mockito.when(tokenUtils.generateToken()).thenReturn(token);

        // Call the method under test
        Map<String, String> requestBody = new HashMap<>();
        requestBody.put("username", username);
        requestBody.put("password", password);
        ResponseEntity<Object> response = userRest.loginPublicAuth(requestBody);

        // Verify the result
        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertEquals(token, ((ApiKeyDto) response.getBody()).getApiKey());
    }

    // User can logout successfully
    @Test
    public void test_user_logout_successfully() {
        // Create mock objects for request and response
        Map<String, String> requestBody = new HashMap<>();
        String token = "test_token";
        UserInfoEntity user = new UserInfoEntity();
        user.setId(1L);

        // Mock userService methods
        Mockito.when(userService.getUserByToken(token)).thenReturn(user);

        // Call the logout method
        ResponseEntity<Object> response = userRest.logout(token);

        // Verify that the userService methods were called
        Mockito.verify(userService).removeToken(user);
        Mockito.verify(userService).updateLastOnline(user);

        // Assert the response status code
        assertEquals(HttpStatus.OK, response.getStatusCode());
    }

    // User with MANAGE_USER permission can get information of a specific user
    @Test
    public void test_getUserById_withManageUserPermission() {
        // Arrange
        Long userId = 1L;
        String token = "valid_token";
        UserInfoEntity user = new UserInfoEntity();
        user.setId(userId);
        user.setUsername("test_user");
        user.setLastOnline(new Date());
        Mockito.when(userService.getUserByToken(token)).thenReturn(user);
        Mockito.when(userService.getUserById(userId)).thenReturn(user);
    
        // Act
        ResponseEntity<Object> response = userRest.getUser(userId, token);
    
        // Assert
        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertEquals(user, response.getBody());
        Mockito.verify(userService, Mockito.times(1)).getUserByToken(token);
        Mockito.verify(userService, Mockito.times(1)).getUserById(userId);
    }

    // User can get own user information
    @Test
    public void test_getOwnUserInfo() {
        // Create a mock user and token
        UserInfoEntity mockUser = new UserInfoEntity("testUser", "password", "testUser@gmail.com", true);
        String mockToken = "mockToken";
    
        // Set up the mock behavior for the userService
        Mockito.when(userService.getUserByToken(Mockito.anyString())).thenReturn(mockUser);
    
        // Set up the mock behavior for the tokenUtils
        Mockito.when(tokenUtils.generateToken()).thenReturn(mockToken);
    
        // Call the method under test
        ResponseEntity<Object> response = userRest.self(mockToken);
    
        // Assert the response status code and body
        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertEquals(new UserDto(mockUser.getId(), mockUser.getUsername(), mockUser.getLastOnline()).toString(), response.getBody().toString());
    
        // Verify that the userService method was called with the correct arguments
        Mockito.verify(userService).getUserByToken(mockToken);
    }

    // User with MANAGE_USER permission can get list of all users
    /*@Test
    public void test_manage_user_permission_get_all_users() {
        // Create a list of users to be returned by the userServiceMock
        List<UserInfoEntity> users = new ArrayList<>();
        users.add(new UserInfoEntity("user1", "password", "user1@gmail.com", true));
        users.add(new UserInfoEntity("user2", "password", "user2@gmail.com", true));
        users.add(new UserInfoEntity("user3", "password", "user3@gmail.com", true));

        // Set up the mock behavior for the userServiceMock
        Mockito.when(userService.getAll()).thenReturn(users);

        // Create an instance of the UserRest class and inject the mock dependencies

        // Set up the required permission for the test
        AuthRequest authRequestAnnotation = Mockito.mock(AuthRequest.class);
        Mockito.when(authRequestAnnotation.requiredPermission()).thenReturn(Permissions.MANAGE_USER);

        // Set up the token header for the test
        String token = "test_token";

        // Call the method under test
        ResponseEntity<Object> response = userRest.users(token);

        // Verify the mock interactions
        Mockito.verify(userService).getAll();

        // Assert the expected response
        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertEquals(users, response.getBody());
    }*/

    // User cannot login with incorrect credentials
    @Test
    public void test_login_with_incorrect_credentials() {
        // Arrange
        String username = "testUser";
        String password = "incorrectPassword";
        Map<String, String> requestBody = new HashMap<>();
        requestBody.put("username", username);
        requestBody.put("password", password);
    
        UserInfoEntity userInfoEntity = new UserInfoEntity();
        userInfoEntity.setUsername(username);
        userInfoEntity.setPassword(passwordEncoder.encode("correctPassword"));
        userInfoEntity.setVerified(true);
    
        Mockito.when(userService.getUserByUsername(username)).thenReturn(userInfoEntity);
    
        // Act
        ResponseEntity<Object> response = userRest.loginPublicAuth(requestBody);
    
        // Assert
        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
        assertNotNull(response.getBody());
        assertTrue(response.getBody() instanceof ErrorDto);
        ErrorDto errorDto = (ErrorDto) response.getBody();
        assertEquals("Incorrect username or password", errorDto.getError());
    }

    // User with MANAGE_USER permission can change roles of a user
    @Test
    public void test_changeRolesOfUser() {
        // Create test data
        Long userId = 1L;
        String token = "token";

        Role role1 = new Role();
        role1.setName("Admin");
        Role role2 = new Role();
        role2.setName("User");
        List<Role> roles = Arrays.asList(role1, role2);
    
        // Create a mock UserInfoEntity
        UserInfoEntity user = new UserInfoEntity();
        user.setId(userId);
    
        // Mock the getUserByToken method to return the mock UserInfoEntity
        Mockito.when(userService.getUserById(userId)).thenReturn(user);
    
        // Call the changeRolesOfUser method
        ResponseEntity<Object> response = userRest.changeRolesOfUser(token, userId, roles);
    
        // Verify that the userService.changeRolesOfUser method was called with the correct arguments
        Mockito.verify(userService).changeRolesOfUser(userId, roles);
    
        // Verify that the response has a status code of CREATED
        assertEquals(HttpStatus.CREATED, response.getStatusCode());
    }

    // User cannot login with unverified email address
    /*@Test
    public void test_unverified_email_login() {
        // Create test data
        String username = "testUser";
        String password = "testPassword";
        String entryCode = "testEntryCode";
        String token = "testToken";
        UserInfoEntity userInfoEntity = new UserInfoEntity(username);
        userInfoEntity.setVerified(false);

        // Mock the userService methods
        Mockito.when(userService.getUserByUsername(username)).thenReturn(userInfoEntity);
        Mockito.when(userService.getUserByToken(token)).thenReturn(userInfoEntity);
        Mockito.when(userService.updateToken(userInfoEntity.getId(), token)).thenReturn(true);
        Mockito.when(userService.updateLastOnline(userInfoEntity)).thenReturn(true);

        // Mock the passwordEncoder method
        Mockito.when(passwordEncoder.matches(password, userInfoEntity.getPassword())).thenReturn(true);

        // Mock the systemService method
        Mockito.when(systemService.checkEntryCode(entryCode)).thenReturn(true);

        // Mock the tokenUtils method
        Mockito.when(tokenUtils.generateToken()).thenReturn(token);

        // Test the loginPublicAuth method
        Map<String, String> requestBody = new HashMap<>();
        requestBody.put("username", username);
        requestBody.put("password", password);
        ResponseEntity<Object> response = userRest.loginPublicAuth(requestBody);

        // Verify the response
        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
        assertEquals(ErrorDto.class, response.getBody().getClass());
        assertEquals("Email address is not verified yet", ((ErrorDto) response.getBody()).getError());
    }*/

    // User cannot delete non-existent user
    @Test
    public void test_cannot_delete_nonexistent_user() {
        // Arrange
        Long userId = 1L;
        String token = "token";
        String expectedErrorMessage = "User with id " + userId + " does not exist";

        Mockito.when(userService.getUserById(userId)).thenReturn(null);
    
        // Act
        ResponseEntity<Object> response = userRest.deleteUser(userId, token);
    
        // Assert
        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
        ErrorDto errorDto = (ErrorDto) response.getBody();
        assertEquals(expectedErrorMessage, errorDto.getError());
    }

    // User cannot verify email address with incorrect code
    @Test
    public void test_cannot_verify_email_with_incorrect_code() {
        // Set up the test data
        String email = "test@example.com";
        String code = "incorrect_code";
        Map<String, String> input = new HashMap<>();
        input.put("code", code);
        input.put("email", email);

        // Mock the userService behavior
        UserInfoEntity user = new UserInfoEntity();
        Mockito.when(userService.verifyEmail(email, code)).thenReturn(false);
        Mockito.when(userService.getUserByEmail(email)).thenReturn(user);

        // Perform the test
        ResponseEntity<Object> response = userRest.verifyAccount(input);

        // Verify the result
        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
        assertTrue(response.getBody() instanceof ErrorDto);
        ErrorDto errorDto = (ErrorDto) response.getBody();
        assertEquals("verification code is wrong", errorDto.getError());

        // Verify the interactions with the mocks
        Mockito.verify(userService).verifyEmail(email, code);
        Mockito.verifyNoMoreInteractions(userService);
    }

    // User cannot get information of non-existent user
    @Test
    public void test_cannot_get_nonexistent_user() {
        // Arrange
        Long nonExistentUserId = 100L;
        String token = "valid_token";

        Mockito.when(userService.getUserById(nonExistentUserId)).thenReturn(null);

        // Act
        ResponseEntity<Object> response = userRest.getUser(nonExistentUserId, token);

        // Assert
        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
        ErrorDto errorDto = (ErrorDto) response.getBody();
        assertNotNull(errorDto);
        assertEquals("User with id " + nonExistentUserId + " does not exist", errorDto.getError());
    }

    // User cannot resend email verification with verified email address
    @Test
    public void test_cannot_resend_email_verification_with_verified_email_address() throws MessagingException, IOException {
        UserInfoEntity user = new UserInfoEntity();
        user.setEmail("verified@example.com");
        user.setVerified(true);

        // Create the request body with a verified email address
        Map<String, String> requestBody = new HashMap<>();
        requestBody.put("email", user.getEmail());

        Mockito.when(userService.getUserByEmail("verified@example.com")).thenReturn(user);
    
        // Call the method under test
        ResponseEntity<Object> response = userRest.resendEmail(requestBody);
    
        // Verify that the UserService method is not called
        Mockito.verify(userService, Mockito.never()).sendEmailVerification(Mockito.any(UserInfoEntity.class));
    
        // Verify the response status code and body
        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
        assertEquals("email is already verified", ((ErrorDto)response.getBody()).getError());
    }

    // User cannot change roles of non-existent user
    @Test
    public void test_cannot_change_roles_of_nonexistent_user() {
        // Create the request body with a non-existent user ID and roles
        Long userId = 100L;
        Role role1 = new Role();
        role1.setName("Admin");
        Role role2 = new Role();
        role2.setName("User");
        List<Role> roles = Arrays.asList(role1, role2);
        Map<String, Object> requestBody = new HashMap<>();
        requestBody.put("id", userId);
        requestBody.put("roles", roles);
    
        // Mock the getUserById method to return null
        Mockito.when(userService.getUserById(userId)).thenReturn(null);
    
        // Call the changeRolesOfUser method and capture the response
        ResponseEntity<Object> response = userRest.changeRolesOfUser("token", userId, roles);
    
        // Verify that the getUserById method was called with the correct ID
        Mockito.verify(userService).getUserById(userId);
    
        // Verify that the response has the correct status code and error message
        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
        assertEquals("user with id not found", ((ErrorDto) response.getBody()).getError());
    }

}