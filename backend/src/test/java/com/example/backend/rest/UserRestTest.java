package com.example.backend.rest;
// Generated by CodiumAI

import com.example.backend.Repository.Permissions;
import com.example.backend.Repository.Role;
import com.example.backend.Repository.UserInfoEntity;
import com.example.backend.ResponseDtos.ApiKeyDto;
import com.example.backend.ResponseDtos.ErrorDto;
import com.example.backend.ResponseDtos.UserDto;
import com.example.backend.annotations.AuthRequest;

import com.example.backend.system_management.SystemService;
import com.example.backend.user_management.UserService;
import com.example.backend.util.TokenUtils;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.crypto.password.PasswordEncoder;

import java.util.*;

import static org.junit.jupiter.api.Assertions.*;

public class UserRestTest {
    // User can login with correct credentials
    @Test
    public void test_login_with_correct_credentials() {
        // Mock dependencies
        UserService userService = Mockito.mock(UserService.class);
        PasswordEncoder passwordEncoder = Mockito.mock(PasswordEncoder.class);
        TokenUtils tokenUtils = Mockito.mock(TokenUtils.class);

        // Create instance of UserRest
        UserRest userRest = new UserRest();
        userRest.userService = userService;
        userRest.passwordEncoder = passwordEncoder;
        userRest.tokenUtils = tokenUtils;

        // Set up test data
        String username = "testUser";
        String password = "testPassword";
        String token = "testToken";

        Map<String, String> requestBody = new HashMap<>();
        requestBody.put("username", username);
        requestBody.put("password", password);

        UserInfoEntity userInfoEntity = new UserInfoEntity();
        userInfoEntity.setId(1L);
        userInfoEntity.setUsername(username);
        userInfoEntity.setPassword(password);
        userInfoEntity.setVerified(true);

        // Set up mock behavior
        Mockito.when(userService.getUserByUsername(username)).thenReturn(userInfoEntity);
        Mockito.when(passwordEncoder.matches(password, userInfoEntity.getPassword())).thenReturn(true);
        Mockito.when(tokenUtils.generateToken()).thenReturn(token);

        // Perform the test
        ResponseEntity<Object> response = userRest.loginPublicAuth(requestBody);

        // Verify the result
        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertEquals(new ApiKeyDto(token), response.getBody());
    }

    // User can register with unique username
    @Test
    public void test_register_with_unique_username() {
        // Mock dependencies
        UserService userService = Mockito.mock(UserService.class);
        TokenUtils tokenUtils = Mockito.mock(TokenUtils.class);

        // Create instance of UserRest
        UserRest userRest = new UserRest();
        userRest.userService = userService;
        userRest.tokenUtils = tokenUtils;

        // Set up test data
        String username = "testUser";
        String token = "testToken";

        Map<String, String> requestBody = new HashMap<>();
        requestBody.put("username", username);

        UserInfoEntity userInfoEntity = new UserInfoEntity();
        userInfoEntity.setId(1L);
        userInfoEntity.setUsername(username);

        // Set up mock behavior
        Mockito.when(userService.getUserByUsername(username)).thenReturn(null);
        Mockito.when(userService.registerNewUser(Mockito.any(UserInfoEntity.class))).thenReturn(userInfoEntity);
        Mockito.when(tokenUtils.generateToken()).thenReturn(token);

        // Perform the test
        ResponseEntity<Object> response = userRest.loginPublic(requestBody);

        // Verify the result
        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertEquals(new ApiKeyDto(token), response.getBody());
    }

    // User can verify email address
    @Test
    public void test_verify_email_address() {
        // Mock dependencies
        UserService userService = Mockito.mock(UserService.class);
        TokenUtils tokenUtils = Mockito.mock(TokenUtils.class);

        // Create instance of UserRest
        UserRest userRest = new UserRest();
        userRest.userService = userService;
        userRest.tokenUtils = tokenUtils;

        // Set up test data
        String code = "testCode";
        String email = "test@example.com";
        String token = "testToken";

        Map<String, String> input = new HashMap<>();
        input.put("code", code);
        input.put("email", email);

        UserInfoEntity userInfoEntity = new UserInfoEntity();
        userInfoEntity.setId(1L);
        userInfoEntity.setEmail(email);

        // Set up mock behavior
        Mockito.when(userService.verifyEmail(email, code)).thenReturn(true);
        Mockito.when(userService.getUserByEmail(email)).thenReturn(userInfoEntity);
        Mockito.when(tokenUtils.generateToken()).thenReturn(token);

        // Perform the test
        ResponseEntity<Object> response = userRest.verifyAccount(input);

        // Verify the result
        assertEquals(HttpStatus.CREATED, response.getStatusCode());
        assertEquals(new ApiKeyDto(token), response.getBody());
    }

    // User can login with verified email address
    @Test
    public void test_login_with_verified_email() {
        // Mock dependencies
        SystemService systemService = Mockito.mock(SystemService.class);
        UserService userService = Mockito.mock(UserService.class);
        PasswordEncoder passwordEncoder = Mockito.mock(PasswordEncoder.class);
        TokenUtils tokenUtils = Mockito.mock(TokenUtils.class);

        // Create test data
        String username = "testUser";
        String password = "testPassword";
        String token = "testToken";
        UserInfoEntity userInfoEntity = new UserInfoEntity(username);
        userInfoEntity.setVerified(true);

        // Set up mock behavior
        Mockito.when(userService.getUserByUsername(username)).thenReturn(userInfoEntity);
        Mockito.when(passwordEncoder.matches(password, userInfoEntity.getPassword())).thenReturn(true);
        Mockito.when(tokenUtils.generateToken()).thenReturn(token);

        // Create instance of UserRest
        UserRest userRest = new UserRest();
        userRest.setSystemService(systemService);
        userRest.setUserService(userService);
        userRest.setPasswordEncoder(passwordEncoder);
        userRest.setTokenUtils(tokenUtils);

        // Call the method under test
        Map<String, String> requestBody = new HashMap<>();
        requestBody.put("username", username);
        requestBody.put("password", password);
        ResponseEntity<Object> response = userRest.loginPublicAuth(requestBody);

        // Verify the result
        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertEquals(new ApiKeyDto(token), response.getBody());
    }

    // User can logout successfully
    @Test
    public void test_user_logout_successfully() {
        // Mock dependencies
        SystemService systemServiceMock = Mockito.mock(SystemService.class);
        UserService userServiceMock = Mockito.mock(UserService.class);
        PasswordEncoder passwordEncoderMock = Mockito.mock(PasswordEncoder.class);
        TokenUtils tokenUtilsMock = Mockito.mock(TokenUtils.class);

        // Create instance of UserRest and set mocked dependencies
        UserRest userRest = new UserRest();
        userRest.setSystemService(systemServiceMock);
        userRest.setUserService(userServiceMock);
        userRest.setPasswordEncoder(passwordEncoderMock);
        userRest.setTokenUtils(tokenUtilsMock);

        // Create mock objects for request and response
        Map<String, String> requestBody = new HashMap<>();
        String token = "test_token";
        UserInfoEntity user = new UserInfoEntity();
        user.setId(1L);

        // Mock userService methods
        Mockito.when(userServiceMock.getUserByToken(token)).thenReturn(user);

        // Call the logout method
        ResponseEntity<Object> response = userRest.logout(token);

        // Verify that the userService methods were called
        Mockito.verify(userServiceMock).removeToken(user);
        Mockito.verify(userServiceMock).updateLastOnline(user);

        // Assert the response status code
        assertEquals(HttpStatus.OK, response.getStatusCode());
    }

    // User with MANAGE_USER permission can get information of a specific user
    @Test
    public void test_getUserById_withManageUserPermission() {
        // Arrange
        Long userId = 1L;
        String token = "valid_token";
        UserInfoEntity user = new UserInfoEntity();
        user.setId(userId);
        user.setUsername("test_user");
        user.setLastOnline(new Date());
        when(userService.getUserByToken(token)).thenReturn(user);
        when(userService.getUserById(userId)).thenReturn(user);
    
        // Act
        ResponseEntity<Object> response = userRest.getUser(userId, token);
    
        // Assert
        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertEquals(user, response.getBody());
        verify(userService, times(1)).getUserByToken(token);
        verify(userService, times(1)).getUserById(userId);
    }

    // User can get own user information
    @Test
    public void test_getOwnUserInfo() {
        // Mock the dependencies
        UserService userServiceMock = Mockito.mock(UserService.class);
        TokenUtils tokenUtilsMock = Mockito.mock(TokenUtils.class);
    
        // Create a test instance of UserRest and inject the mocks
        UserRest userRest = new UserRest();
        userRest.setUserService(userServiceMock);
        userRest.setTokenUtils(tokenUtilsMock);
    
        // Create a mock user and token
        UserInfoEntity mockUser = new UserInfoEntity(1L, "testUser", "password", true);
        String mockToken = "mockToken";
    
        // Set up the mock behavior for the userService
        Mockito.when(userServiceMock.getUserByToken(Mockito.anyString())).thenReturn(mockUser);
    
        // Set up the mock behavior for the tokenUtils
        Mockito.when(tokenUtilsMock.generateToken()).thenReturn(mockToken);
    
        // Call the method under test
        ResponseEntity<Object> response = userRest.self(mockToken);
    
        // Assert the response status code and body
        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertEquals(new UserDto(mockUser.getId(), mockUser.getUsername(), mockUser.getLastOnline()), response.getBody());
    
        // Verify that the userService method was called with the correct arguments
        Mockito.verify(userServiceMock).getUserByToken(mockToken);
    }

    // User with MANAGE_USER permission can get list of all users
    @Test
    public void test_manage_user_permission_get_all_users() {
        // Mock the userService and systemService dependencies
        UserService userServiceMock = Mockito.mock(UserService.class);
        SystemService systemServiceMock = Mockito.mock(SystemService.class);

        // Create a list of users to be returned by the userServiceMock
        List<UserInfoEntity> users = new ArrayList<>();
        users.add(new UserInfoEntity(1L, "user1", true));
        users.add(new UserInfoEntity(2L, "user2", true));
        users.add(new UserInfoEntity(3L, "user3", true));

        // Set up the mock behavior for the userServiceMock
        Mockito.when(userServiceMock.getAll()).thenReturn(users);

        // Create an instance of the UserRest class and inject the mock dependencies
        UserRest userRest = new UserRest();
        userRest.setUserService(userServiceMock);
        userRest.setSystemService(systemServiceMock);

        // Set up the required permission for the test
        AuthRequest authRequestAnnotation = Mockito.mock(AuthRequest.class);
        Mockito.when(authRequestAnnotation.requiredPermission()).thenReturn(Permissions.MANAGE_USER);

        // Set up the token header for the test
        String token = "test_token";

        // Call the method under test
        ResponseEntity<Object> response = userRest.users(token);

        // Verify the mock interactions
        Mockito.verify(userServiceMock).getAll();

        // Assert the expected response
        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertEquals(users, response.getBody());
    }

    // User cannot login with incorrect credentials
    @Test
    public void test_login_with_incorrect_credentials() {
        // Arrange
        String username = "testUser";
        String password = "incorrectPassword";
        Map<String, String> requestBody = new HashMap<>();
        requestBody.put("username", username);
        requestBody.put("password", password);
    
        UserInfoEntity userInfoEntity = new UserInfoEntity();
        userInfoEntity.setUsername(username);
        userInfoEntity.setPassword(passwordEncoder.encode("correctPassword"));
    
        when(userService.getUserByUsername(username)).thenReturn(userInfoEntity);
    
        // Act
        ResponseEntity<Object> response = userRest.loginPublicAuth(requestBody);
    
        // Assert
        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
        assertNotNull(response.getBody());
        assertTrue(response.getBody() instanceof ErrorDto);
        ErrorDto errorDto = (ErrorDto) response.getBody();
        assertEquals("Incorrect username or password", errorDto.getError());
    }

    // User with MANAGE_USER permission can change roles of a user
    @Test
    public void test_changeRolesOfUser() {
        // Create a mock UserService
        UserService userServiceMock = Mockito.mock(UserService.class);
    
        // Create a mock SystemService
        SystemService systemServiceMock = Mockito.mock(SystemService.class);
    
        // Create a mock PasswordEncoder
        PasswordEncoder passwordEncoderMock = Mockito.mock(PasswordEncoder.class);
    
        // Create a mock TokenUtils
        TokenUtils tokenUtilsMock = Mockito.mock(TokenUtils.class);
    
        // Create an instance of UserRest and inject the mocks
        UserRest userRest = new UserRest();
        userRest.setUserService(userServiceMock);
        userRest.setSystemService(systemServiceMock);
        userRest.setPasswordEncoder(passwordEncoderMock);
        userRest.setTokenUtils(tokenUtilsMock);
    
        // Create test data
        Long userId = 1L;
        String token = "token";
        List<Role> roles = Arrays.asList(Role.ADMIN, Role.USER);
    
        // Create a mock UserInfoEntity
        UserInfoEntity user = new UserInfoEntity();
        user.setId(userId);
    
        // Mock the getUserByToken method to return the mock UserInfoEntity
        Mockito.when(userServiceMock.getUserByToken(token)).thenReturn(user);
    
        // Call the changeRolesOfUser method
        ResponseEntity<Object> response = userRest.changeRolesOfUser(token, userId, roles);
    
        // Verify that the userService.changeRolesOfUser method was called with the correct arguments
        Mockito.verify(userServiceMock).changeRolesOfUser(userId, roles);
    
        // Verify that the response has a status code of CREATED
        assertEquals(HttpStatus.CREATED, response.getStatusCode());
    }

    // User cannot login with unverified email address
    @Test
    public void test_unverified_email_login() {
        // Mock the dependencies
        SystemService systemService = Mockito.mock(SystemService.class);
        UserService userService = Mockito.mock(UserService.class);
        PasswordEncoder passwordEncoder = Mockito.mock(PasswordEncoder.class);
        TokenUtils tokenUtils = Mockito.mock(TokenUtils.class);

        // Create a test instance of UserRest
        UserRest userRest = new UserRest();
        userRest.setSystemService(systemService);
        userRest.setUserService(userService);
        userRest.setPasswordEncoder(passwordEncoder);
        userRest.setTokenUtils(tokenUtils);

        // Create test data
        String username = "testUser";
        String password = "testPassword";
        String entryCode = "testEntryCode";
        String token = "testToken";
        UserInfoEntity userInfoEntity = new UserInfoEntity(username);
        userInfoEntity.setVerified(false);

        // Mock the userService methods
        Mockito.when(userService.getUserByUsername(username)).thenReturn(userInfoEntity);
        Mockito.when(userService.getUserByToken(token)).thenReturn(userInfoEntity);
        Mockito.when(userService.updateToken(userInfoEntity.getId(), token)).thenReturn(true);
        Mockito.when(userService.updateLastOnline(userInfoEntity)).thenReturn(true);

        // Mock the passwordEncoder method
        Mockito.when(passwordEncoder.matches(password, userInfoEntity.getPassword())).thenReturn(true);

        // Mock the systemService method
        Mockito.when(systemService.checkEntryCode(entryCode)).thenReturn(true);

        // Mock the tokenUtils method
        Mockito.when(tokenUtils.generateToken()).thenReturn(token);

        // Test the loginPublicAuth method
        Map<String, String> requestBody = new HashMap<>();
        requestBody.put("username", username);
        requestBody.put("password", password);
        ResponseEntity<Object> response = userRest.loginPublicAuth(requestBody);

        // Verify the response
        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
        assertEquals(ErrorDto.class, response.getBody().getClass());
        assertEquals("Email address is not verified yet", ((ErrorDto) response.getBody()).getError());
    }

    // User cannot delete non-existent user
    @Test
    public void test_cannot_delete_nonexistent_user() {
        // Arrange
        Long userId = 1L;
        String token = "token";
        String expectedErrorMessage = "User with id " + userId + " does not exist";
    
        UserService userServiceMock = Mockito.mock(UserService.class);
        SystemService systemServiceMock = Mockito.mock(SystemService.class);
    
        UserRest userRest = new UserRest();
        userRest.setUserService(userServiceMock);
        userRest.setSystemService(systemServiceMock);
    
        Mockito.when(userServiceMock.getUserById(userId)).thenReturn(null);
    
        // Act
        ResponseEntity<Object> response = userRest.deleteUser(userId, token);
    
        // Assert
        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
        ErrorDto errorDto = (ErrorDto) response.getBody();
        assertEquals(expectedErrorMessage, errorDto.getError());
    }

    // User cannot verify email address with incorrect code
    @Test
    public void test_cannot_verify_email_with_incorrect_code() {
        // Mock the dependencies
        SystemService systemServiceMock = Mockito.mock(SystemService.class);
        UserService userServiceMock = Mockito.mock(UserService.class);
        PasswordEncoder passwordEncoderMock = Mockito.mock(PasswordEncoder.class);
        TokenUtils tokenUtilsMock = Mockito.mock(TokenUtils.class);

        // Create an instance of UserRest and inject the mocks
        UserRest userRest = new UserRest();
        userRest.setSystemService(systemServiceMock);
        userRest.setUserService(userServiceMock);
        userRest.setPasswordEncoder(passwordEncoderMock);
        userRest.setTokenUtils(tokenUtilsMock);

        // Set up the test data
        String email = "test@example.com";
        String code = "incorrect_code";
        Map<String, String> input = new HashMap<>();
        input.put("code", code);
        input.put("email", email);

        // Mock the userService behavior
        UserInfoEntity user = new UserInfoEntity();
        Mockito.when(userServiceMock.verifyEmail(email, code)).thenReturn(false);
        Mockito.when(userServiceMock.getUserByEmail(email)).thenReturn(user);

        // Perform the test
        ResponseEntity<Object> response = userRest.verifyAccount(input);

        // Verify the result
        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
        assertTrue(response.getBody() instanceof ErrorDto);
        ErrorDto errorDto = (ErrorDto) response.getBody();
        assertEquals("verification code is wrong", errorDto.getError());

        // Verify the interactions with the mocks
        Mockito.verify(userServiceMock).verifyEmail(email, code);
        Mockito.verify(userServiceMock).getUserByEmail(email);
        Mockito.verifyNoMoreInteractions(userServiceMock);
    }

    // User cannot get information of non-existent user
    @Test
    public void test_cannot_get_nonexistent_user() {
        // Arrange
        Long nonExistentUserId = 100L;
        String token = "valid_token";
        UserRest userRest = new UserRest();
        UserService userServiceMock = Mockito.mock(UserService.class);
        Mockito.when(userServiceMock.getUserById(nonExistentUserId)).thenReturn(null);
        userRest.setUserService(userServiceMock);

        // Act
        ResponseEntity<Object> response = userRest.getUser(nonExistentUserId, token);

        // Assert
        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
        ErrorDto errorDto = (ErrorDto) response.getBody();
        assertNotNull(errorDto);
        assertEquals("User with id " + nonExistentUserId + " does not exist", errorDto.getError());
    }

    // User cannot resend email verification with verified email address
    @Test
    public void test_cannot_resend_email_verification_with_verified_email_address() {
        // Create a mock UserService
        UserService userServiceMock = Mockito.mock(UserService.class);
    
        // Create a mock SystemService
        SystemService systemServiceMock = Mockito.mock(SystemService.class);
    
        // Create a mock PasswordEncoder
        PasswordEncoder passwordEncoderMock = Mockito.mock(PasswordEncoder.class);
    
        // Create a mock TokenUtils
        TokenUtils tokenUtilsMock = Mockito.mock(TokenUtils.class);
    
        // Create an instance of UserRest and inject the mocks
        UserRest userRest = new UserRest();
        userRest.setUserService(userServiceMock);
        userRest.setSystemService(systemServiceMock);
        userRest.setPasswordEncoder(passwordEncoderMock);
        userRest.setTokenUtils(tokenUtilsMock);
    
        // Create the request body with a verified email address
        Map<String, String> requestBody = new HashMap<>();
        requestBody.put("email", "verified@example.com");
    
        // Call the method under test
        ResponseEntity<Object> response = userRest.resendEmail(requestBody);
    
        // Verify that the UserService method is not called
        Mockito.verify(userServiceMock, Mockito.never()).sendEmailVerification(Mockito.any(UserInfoEntity.class));
    
        // Verify the response status code and body
        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
        assertEquals(new ErrorDto("email is already verified"), response.getBody());
    }

    // User cannot get permissions with invalid token
    @Test
    public void test_invalid_token_permissions() {
        // Mock the UserService
        UserService userServiceMock = Mockito.mock(UserService.class);
    
        // Create a dummy token
        String token = "dummy_token";
    
        // Create a dummy user with the token
        UserInfoEntity user = new UserInfoEntity();
        user.setToken(token);
    
        // Return the dummy user when getUserByToken is called with the token
        Mockito.when(userServiceMock.getUserByToken(token)).thenReturn(user);
    
        // Create an instance of UserRest and set the mocked UserService
        UserRest userRest = new UserRest();
        userRest.setUserService(userServiceMock);
    
        // Call the verifyApiKey method with the dummy token
        ResponseEntity<Object> response = userRest.verifyApiKey(token);
    
        // Assert that the response status is UNAUTHORIZED
        assertEquals(HttpStatus.UNAUTHORIZED, response.getStatusCode());
    }

    // User cannot change roles of non-existent user
    @Test
    public void test_cannot_change_roles_of_nonexistent_user() {
        // Create a mock UserService
        UserService userServiceMock = Mockito.mock(UserService.class);
    
        // Create a mock SystemService
        SystemService systemServiceMock = Mockito.mock(SystemService.class);
    
        // Create a mock PasswordEncoder
        PasswordEncoder passwordEncoderMock = Mockito.mock(PasswordEncoder.class);
    
        // Create a mock TokenUtils
        TokenUtils tokenUtilsMock = Mockito.mock(TokenUtils.class);
    
        // Create an instance of UserRest and inject the mocks
        UserRest userRest = new UserRest();
        userRest.setUserService(userServiceMock);
        userRest.setSystemService(systemServiceMock);
        userRest.setPasswordEncoder(passwordEncoderMock);
        userRest.setTokenUtils(tokenUtilsMock);
    
        // Create the request body with a non-existent user ID and roles
        Long userId = 100L;
        List<Role> roles = Arrays.asList(Role.ADMIN, Role.USER);
        Map<String, Object> requestBody = new HashMap<>();
        requestBody.put("id", userId);
        requestBody.put("roles", roles);
    
        // Mock the getUserById method to return null
        Mockito.when(userServiceMock.getUserById(userId)).thenReturn(null);
    
        // Call the changeRolesOfUser method and capture the response
        ResponseEntity<Object> response = userRest.changeRolesOfUser("token", userId, roles);
    
        // Verify that the getUserById method was called with the correct ID
        Mockito.verify(userServiceMock).getUserById(userId);
    
        // Verify that the response has the correct status code and error message
        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
        assertEquals("User with id " + userId + " does not exist", ((ErrorDto) response.getBody()).getError());
    }

}